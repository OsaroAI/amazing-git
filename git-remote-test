#!/usr/bin/env python

import os
import sys
import logbook

from dulwich import pack

log = logbook.Logger('git-remote-test')
stdin_log = logbook.Logger('stdin')
stdout_log = logbook.Logger('stdout')

def required_capability(f):
	f.git_required = True
	return f

class GitRemoteHandler(object):
	def __init__(self, loghandler = None):
		self.loghandler = loghandler or logbook.NullHandler()
		self.args = sys.argv[1:]

		self.remote_name = None
		self.remote_address = None
		if 2 == len(self.args):
			self.remote_address = self.args[1]
			if self.args[1] != self.args[0]: self.remote_name = self.args[0]

	def handle_command(self, line):
		args = line.split(' ')
		command = args.pop(0)

		stdin_log.debug(line)
		if not hasattr(self, 'git_' + command): raise AttributeError('git requested an unsupported command: %s' % command)
		getattr(self, 'git_' + command)(*args)
		sys.stdout.flush()

	def git_capabilities(self):
		caps = []
		for name in dir(self):
			if 'git_capabilities' == name: continue
			attr = getattr(self,name)
			if name.startswith('git_') and callable(attr):
				caps.append('*' + name[4:] if hasattr(attr, 'git_required') else name[4:])

		log.debug('sending capabilities: %s' % caps)
		for c in caps: print c

		# end with a blank line
		print

	def run(self):
		with self.loghandler.applicationbound():
			log.debug('spawned process: %d' % os.getpid())
			log.debug('remote name: %s' % self.remote_name)
			log.debug('remote address: %s' % self.remote_address)
			while not sys.stdin.closed:
				line = sys.stdin.readline()
				if '' == line: break # EOF
				if '' == line.strip(): break # empty line ends as well
				try:
					self.handle_command(line.rstrip(os.linesep))
				except Exception, e:
					log.exception(e)
					print >>sys.stderr, os.path.basename(sys.argv[0]) + ':', e
					break


class GitServerHandler(GitRemoteHandler):
	def __init__(self, server, *args, **kwargs):
		super(GitServerHandler, self).__init__(*args, **kwargs)
		self.server = server

	def git_connect(self, *args):
		print # "all ok"
		getattr(self.server, args[0].replace('-','_'))(*args[1:])
		sys.stdin.close()


class GitSmartServer(object):
	def send_line(self, line):
		assert line

		l = len(line) + 4 + len(os.linesep)
		if l > 0xFFFF: raise Exception('line too long (%x)' % l)
		output = '%04x%s%s' % (l, line, os.linesep)
		sys.stdout.write(output)
		stdout_log.debug(output)

	def send_eof(self):
		line = '0000' + os.linesep
		sys.stdout.write(line)
		stdout_log.debug(line)

	def recv_line(self):
		buf = sys.stdin.read(4)
		stdin_log.debug('header: ' + buf)
		if '0000' == buf: return '';

		line = sys.stdin.read(int(buf, 16)-4)
		stdin_log.debug('line: %s' % line)
		return line


class TestServer(GitSmartServer):
	def git_receive_pack(self, *args):
		# FIXME: send what we have
		self.send_eof()
		sys.stdout.flush()

		while True:
			line = self.recv_line()
			if '' == line: break

			# FIXME
			log.debug('updating branches: %s' % line)

		# pack version and number of objects
		#version, num_objects = pack.read_pack_header(sys.stdin.read)
		#log.debug('expecting %d objects' % num_objects)

		# 
		#obj_type, obj_data, compressed_size, tail = pack.unpack_object

		packs = pack.PackStreamReader(sys.stdin.read)
		for header, content, comp_len in packs.read_objects():
			log.debug('header: %x comp_len: %d actual length: %d' % (header, comp_len, len("".join(content))))

		# we're done now
		# not entirely sure, but there seems to be no acknowledgement from the server

if __name__ == '__main__':
	GitServerHandler(server = TestServer(), loghandler = logbook.FileHandler('/home/rescue/git-stuff/git-remote-test.log', encoding = 'utf-8')).run()
