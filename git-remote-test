#!/usr/bin/env python

import os
import sys
import logbook

log = logbook.Logger('git-remote-test')
stdin_log = logbook.Logger('stdin')

def required_capability(f):
	f.git_required = True
	return f

class GitRemoteHandler(object):
	def __init__(self, loghandler = None):
		self.loghandler = loghandler or logbook.NullHandler()
		self.args = sys.argv[1:]

		self.remote_name = None
		self.remote_address = None
		if 2 == len(self.args):
			self.remote_address = self.args[1]
			if self.args[1] != self.args[0]: self.remote_name = self.args[0]

	def handle_command(self, line):
		args = line.split(' ')
		command = args.pop(0)

		stdin_log.debug(line)
		try:
			getattr(self, 'git_' + command)(*args)
		except AttributeError:
			raise AttributeError('git requested an unsupported command: %s' % command)
		sys.stdout.flush()

	def git_capabilities(self):
		caps = []
		for name in dir(self):
			if 'git_capabilities' == name: continue
			attr = getattr(self,name)
			if name.startswith('git_') and callable(attr):
				caps.append('*' + name[4:] if hasattr(attr, 'git_required') else name[4:])

		log.debug('sending capabilities: %s' % caps)
		for c in caps: print c

		# end with a blank line
		print

	def run(self):
		with self.loghandler.applicationbound():
			log.debug('spawned process: %d' % os.getpid())
			log.debug('remote name: %s' % self.remote_name)
			log.debug('remote address: %s' % self.remote_address)
			while sys.stdin:
				line = sys.stdin.readline()
				if '' == line: break # EOF
				if '' == line.strip(): break # empty line ends as well
				try:
					self.handle_command(line.rstrip(os.linesep))
				except Exception, e:
					log.exception(e)
					print >>sys.stderr, os.path.basename(sys.argv[0]) + ':', e
					break

class GitRemoteTest(GitRemoteHandler):
	def git_list(self, *args):
		# FIXME: return empty list
		print

	def git_push(self, *args):
		# FIXME
		pass

if __name__ == '__main__':
	GitRemoteTest(loghandler = logbook.FileHandler('/home/rescue/git-stuff/git-remote-test.log')).run()
