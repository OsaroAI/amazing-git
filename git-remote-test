#!/usr/bin/env python

import os
import sys
import logbook

from dulwich import pack
from dulwich.object_store import DiskObjectStore
from dulwich.repo import Repo

log = logbook.Logger('git-remote-test')
stdin_log = logbook.Logger('stdin')
stdout_log = logbook.Logger('stdout')

def required_capability(f):
	f.git_required = True
	return f

import cPickle as pickle
class SimpleStorage(object):
	def __init__(self, filename):
		self.filename = filename
		self.d = {}

		self._load()

	def _save(self):
		with file(self.filename, 'w') as f:
			pickle.dump(self.d, f)

	def _load(self):
		if not os.path.exists(self.filename): return
		with file(self.filename) as f:
			self.d = pickle.load(f)

	def __setitem__(self, key, value):
		self.d[key] = value
		self._save()

	def __getitem__(self, key):
		return self.d[key]

	def keys(self):
		return self.d.keys()

	def iteritems(self):
		return self.d.iteritems()

class GitRemoteHandler(object):
	supported_options = []
	def __init__(self, loghandler = None):
		self.loghandler = loghandler or logbook.NullHandler()
		self.args = sys.argv[1:]

		self.remote_name = None
		self.remote_address = None
		if 2 == len(self.args):
			self.remote_address = self.args[1]
			if self.args[1] != self.args[0]: self.remote_name = self.args[0]

		self.options = {}

	def handle_command(self, line):
		args = line.split(' ')
		command = args.pop(0)

		stdin_log.debug(line)
		if not hasattr(self, 'git_' + command): raise AttributeError('git requested an unsupported command: %s' % command)
		getattr(self, 'git_' + command)(*args)
		try:
			sys.stdout.flush()
		except IOError:
			# git closed the connection
			pass

	def git_capabilities(self):
		caps = []
		for name in dir(self):
			if 'git_capabilities' == name: continue
			attr = getattr(self,name)
			if name.startswith('git_') and callable(attr):
				caps.append('*' + name[4:] if hasattr(attr, 'git_required') else name[4:])

		log.debug('sending capabilities: %s' % caps)
		for c in caps: print c

		# end with a blank line
		print

	def run(self):
		with self.loghandler.applicationbound():
			log.debug('spawned process: %d' % os.getpid())
			log.debug('remote name: %s' % self.remote_name)
			log.debug('remote address: %s' % self.remote_address)
			while not sys.stdin.closed:
				line = sys.stdin.readline()
				if '' == line: break # EOF
				if '' == line.strip(): break # empty line ends as well
				try:
					self.handle_command(line.rstrip(os.linesep))
				except Exception, e:
					log.exception(e)
					print >>sys.stderr, os.path.basename(sys.argv[0]) + ':', e
					break


class GitServerHandler(GitRemoteHandler):
	def __init__(self, server, *args, **kwargs):
		super(GitServerHandler, self).__init__(*args, **kwargs)
		self.server = server

	def git_connect(self, *args):
		print # "all ok"
		getattr(self.server, args[0].replace('-','_'))(*args[1:])
		sys.stdin.close()


class GitSmartServer(object):
	def send_line(self, line):
		assert line

		l = len(line) + 4 + len(os.linesep)
		if l > 0xFFFF: raise Exception('line too long (%x)' % l)
		output = '%04x%s%s' % (l, line, os.linesep)
		sys.stdout.write(output)
		stdout_log.debug(output)

	def send_eof(self):
		line = '0000' + os.linesep
		sys.stdout.write(line)
		stdout_log.debug(line)

	def recv_line(self):
		buf = sys.stdin.read(4)
		stdin_log.debug('header: ' + buf)
		if '0000' == buf: return '';

		line = sys.stdin.read(int(buf, 16)-4)
		stdin_log.debug('line: %s' % line)
		return line


class TestServer(GitSmartServer):
	def git_receive_pack(self, *args):
		# FIXME: send what we have
		self.send_eof()
		sys.stdout.flush()

		while True:
			line = self.recv_line()
			if '' == line: break

			# FIXME
			log.debug('updating branches: %s' % line)

		# pack version and number of objects
		#version, num_objects = pack.read_pack_header(sys.stdin.read)
		#log.debug('expecting %d objects' % num_objects)

		# 
		#obj_type, obj_data, compressed_size, tail = pack.unpack_object

		packs = pack.PackStreamReader(sys.stdin.read)
		for header, content, comp_len in packs.read_objects():
			log.debug('header: %x comp_len: %d actual length: %d' % (header, comp_len, len("".join(content))))

		# we're done now
		# not entirely sure, but there seems to be no acknowledgement from the server


class TestHandler(GitRemoteHandler):
#	supported_options = ['dry-run']
	# FIXME: use fallback to use smart protocol for what we can actually push?

	def __init__(self, ref_store, object_store, *args, **kwargs):
		super(TestHandler, self).__init__(*args, **kwargs)
		self.ref_store = ref_store
		self.object_store = object_store

	def git_list(self, *args):
		for name, hash in self.ref_store.iteritems():
			print '%s %s' % (hash, name)
		print

	def git_push(self, target):
		log.debug('push args: %s' % target)
		src, dst = target.split(':')
		log.debug('push: %s to %s' % (src, dst))

		# use git-rev-list to find out what we need to transfer
		# FIXME: be smart
		local = Repo('.git')		

		# do the actual push
		print "ok %s" % dst
		print

	def git_option(self, name, value):
		if name in self.supported_options:
			self.options[name] = value
			log.debug('option %s: %s' % (name, value))
			print "ok"
		else:
			log.debug('option %s unsupported' % name)
			print "unsupported"

if __name__ == '__main__':
	ref_store = SimpleStorage('test-ref-store.pickle')
	object_store = SimpleStorage('test-object-store.pickle')

	loghandler = logbook.FileHandler('git-remote-test.log', encoding = 'utf-8')
	#GitServerHandler(server = TestServer(), loghandler = loghandler).run()
	TestHandler(ref_store, object_store, loghandler).run()
